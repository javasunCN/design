# **面向对象设计七大原则**
### 1.**单一职责原则(Single Responsibility Principle)**
> 每一个类应该专注于做一件事情。

### 2.**里氏替换原则（Liskov Substitution Principle）**
> 超类存在的地方，子类是可以替换的。

### 3.**依赖倒置原则（Dependence Inversion Principle）**
> 实现尽量依赖抽象，不依赖具体实现。

### 4.**接口隔离原则（Interface Segregation Principle）**
> 应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。

### 5.**迪米特法则（Law Of Demeter）**
> 又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。

### 6.**开闭原则（Open Close Principle）**
> 面向扩展开放，面向修改关闭。

### 7.**组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）**
> 尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。


# **设计模式**
## 设计模式视图
![设计模式之间的关系](http://m.qpic.cn/psb?/V11AXMr91seOnq/1ob0E.9Gtkj.RmDie0M7hD*xVZmqOjLdTx.H2*1FIHI!/b/dGgBAAAAAAAA&bo=fwIAAwAAAAARF14!&rf=viewer_4)
![设计模式视图](http://m.qpic.cn/psb?/V11AXMr91seOnq/YNC083qmyQZcKyXGOcEKh56lhkNJ7rCt32LBr*UxXiI!/b/dPMAAAAAAAAA&bo=AAR*AgAAAAARB0k!&rf=viewer_4)


## 设计模式详解
### 创建型模式
### 1. ***抽象工厂模式（Abstract Factory）***

* 概念：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。
![](http://m.qpic.cn/psb?/V11AXMr91seOnq/itE4wOduSkobHWGwElYUskhrUgY2EASnXXH.dm5sSN0!/b/dPQAAAAAAAAA&bo=DQOAAgAAAAABB6w!&rf=viewer_4)
* 角色：
1. 抽象工厂（AbstractFactory）
2. 具体工厂（ConcreteFactory1/ConcreteFactory2）
3. 抽象产品（AbstractProductA/AbstractProductB）
4. 具体产品（ProductA1/ProductA2、ProductB1/ProductB2）
* **理解** 抽象工厂模式是将工厂创建、对象创建都进行抽象，通过调用抽象工厂创建不同的抽象工厂类来完成不同的产品功能实现。
* 抽象工厂模式与工厂方法模式的最大区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构。


> `概念：产品族和产品等级`
> ![](http://m.qpic.cn/psb?/V11AXMr91seOnq/64NMZXTtlVb.tlpskLOv5wSDnlb4FKZk0CpDeexyhkQ!/b/dPMAAAAAAAAA&bo=HgRcAgAAAAARB3Q!&rf=viewer_4)

#### **`在什么情况下应当使用抽象工厂模式:`**
**`1.一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。`**
**`2.这个系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。`**
**`3.同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。`**
**`4.系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。`**

#### **==抽象工厂模式优缺点:==**
1. 优点
	* 分离接口和实现
	* 切换产品族变的容易
2. 缺点
	* 太不容易扩展新的产品

### 2. ***建造者模式（Builder）***
* 概念：将一个对象内部属性与类的创建过程分割，从而一个建造过程产生不同的对象。
![](http://m.qpic.cn/psb?/V11AXMr91seOnq/hBz7XBcRNXDw367fEj1UGr3z1B1vLiJOQ0kuJQX9VQA!/b/dD8BAAAAAAAA&bo=cAZ.AgAAAAARBzo!&rf=viewer_4)

* ==建造者角色==
	* 抽象建造者角色（Builder）：定义一个抽象接口，规范对象各个组成成分的建造。
	* 具体建造者角色（ConcreteBuilder）：实现抽象接口，并在应用程序调用下实现产品的实例创建。
	* 导演者角色（Director）：调用具体建造者角色创建产品对象。
	* 产品角色（Product）：所要创建的复杂的产品。
	
**`建造者模式两个重要部分：1、部件构造和产品装配（Builder）；2、整体构建的建造算法（Director）；`**
建造者重心在于分离算法和具体的构造实现，从而使得算法可以重用。

#### **`在什么情况下应当使用建造者模式:`**
> **`1. 需要生成的产品对象有复杂的内部结构，每一个内部成分本身可以是对象，也可以仅仅是一个对象（即产品对象）的一个组成部分。`**
> **`2. 需要生成的产品对象的属性相互依赖。建造模式可以强制实行一种分步骤进行的建造过程，因此，如果产品对象的一个属性必须在另一个属性被赋值之后才可以被赋值，使用建造模式是一个很好的设计思想。`**
> **`3. 在对象创建过程中会使用到系统中的其他一些对象，这些对象在产品对象的创建过程中不易得到。`**


### 3. ***工厂方法模式（Factory Method）***

* 概念：专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类，简单工厂(Simple Factory)模式又称为静态工厂方法(Static Factory Method)模式，属于类的创建型模式，但其不属于23种GOF设计模式之一，通常它根据自变量的不同返回不同的类的实例。
![](http://m.qpic.cn/psb?/V11AXMr91seOnq/HTwHGB1Q*kX7qJ9UPBXVev94aJ5iV1wuMkrQE3.frEI!/b/dPIAAAAAAAAA&bo=2QKAAgAAAAARB2k!&rf=viewer_4)
* 角色：
1. 	工厂角色（OperationFactory）:简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。可被外界直接调用来创建产品对象。
2. 抽象产品角色（Operation）:简单工厂所创建的所有产品的父类，它描述所有实例所共有的公共接口
3. 具体产品角色（Mul\Add\Div\sub...）:简单工厂模式创建目标，所创建的对象都是充当这个角色的某个具体类的实例。
* **理解**：通过工厂类对象调用生产方法，传入类标识，创建不同的类对象，所有的具体实现类都有一个抽象父类


### 4. ***原型模式（Prototype）***
* 概念:通过给定一个原型对象来指明所有创建的对象的类型，然后复制这个原型对象的办法创建出更多同类型的对象。两种表现形式：1、简单形式；2、登记形式；
![](http://m.qpic.cn/psb?/V11AXMr91seOnq/PtNXkM*ELhUmKfaIi1Iny2t4la8Rl6GQHD2UeAfA3*U!/b/dF4BAAAAAAAA&bo=AAYEAgAAAAARFyA!&rf=viewer_4)

* ==建造者角色==
	* 客户角色（Client）：客户端提出创建对象的请求；
	* 抽象原型角色（Prototype）：抽象角色，给出所有的具体原型类所需要的接口；一般由一个接口或者抽象类实现
	* 具体原型角色（Concrete Prototype）：被复制的对象
	* 原型管理器角色（PrototypeManager）：登记形式下才有，创建具体的原型类对象，并记录每一个被创建的对象。

* ==简单形式和登记形式比较==	
	* 如果需要创建的原型对象数目较少而且比较固定的话，可以采取简单形式。在这种情况下，原型对象的引用可以由客户端自己保存。
	* 如果要创建的原型对象数目不固定的话，可以采取登记形式。在这种情况下，客户端不保存对原型对象的引用，这个任务被交给管理员对象。在复制一个原型对象之前，客户端可以查看管理员对象是否已经有一个满足要求的原型对象。如果有，可以直接从管理员类取得这个对象引用；如果没有，客户端就需要自行复制此原型对象。

###### JAVA中对象的克隆方法
> 
> 特别注意：使用Object中的clone方法时，对象以及对象对其他的对象引用也会同时被复制一份；
> #### 克隆满足的条件
> 		1、对任何的对象x，都有：x.clone()!=x。换言之，克隆对象与原对象不是同一个对象。
> 		2、对任何的对象x，都有：x.clone().getClass() == x.getClass()，换言之，克隆对象与原对象的类型一样。
> 		3、如果对象x的equals()方法定义其恰当的话，那么x.clone().equals(x)应当成立的。
> 
> #### 浅克隆和深克隆
> ##### 浅度克隆
> 		只负责克隆按值传递的数据（比如基本数据类型、String类型），而不复制它所引用的对象，换言之，所有的对其他对象的引用都仍然指向原来的对象。
> ##### 深度克隆
> 		除了浅度克隆要克隆的值外，还负责克隆引用类型的数据。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深度克隆把要复制的对象所引用的对象都复制了一遍，而这种对被引用到的对象的复制叫做间接复制。
>		深度克隆要深入到多少层，是一个不易确定的问题。在决定以深度克隆的方式复制一个对象的时候，必须决定对间接复制的对象时采取浅度克隆还是继续采用深度克隆。因此，在采取深度克隆时，需要决定多深才算深。此外，在深度克隆的过程中，很可能会出现循环引用的问题，必须小心处理。

#### 原型模式的优缺点
> #### 优点
> 		原型模式允许在运行时动态改变具体的实现类型。原型模式可以在运行期间，由客户来注册符合原型接口的实现类型，也可以动态地改变具体的实现类型，看起来接口没有任何变化，但其实运行的已经是另外一个类实例了。因为克隆一个原型就类似于实例化一个类。
> #### 缺点
> 		原型模式最主要的缺点是每一个类都必须配备一个克隆方法。配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类来说不是很难，而对于已经有的类不一定很容易，特别是当一个类引用不支持序列化的间接对象，或者引用含有循环结构的时候。

### 5. ***单例模式（Singleton）***
* 概念：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。
* 特点：
	* 单例类只能有一个实例。
	* 单例类必须自己创建自己的唯一实例。
	* 单例类必须给所有其他对象提供这一实例。

### 单例 - 饿汉式模式
``` java
	 // 单例模式 —— 饿汉模式
	public class EagerSingleton {
		private static EagerSingleton instance = new EagerSingleton();
		
		private EagerSingleton() {}
		
		// 静态工厂方法
		public static EagerSingleton getInstance() {
			return instance;
		}
	}
```
> 饿汉式是典型的空间换时间，当类装载的时候就会创建类的实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断，节省了运行时间。

### 单例 - 懒汉式模式
``` java
	// 单例模式 —— 懒汉模式
	public class LazySingleton {
	
		private static LazySingleton instance = null;
		
		private LazySingleton() {}
		
		public static synchronized LazySingleton getInstance() {
			if (instance == null) {
				instance = new LazySingleton();
			}
			return instance;
		}
	}
```
> ###### 懒汉式是典型的时间换空间,就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。当然，如果一直没有人使用的话，那就不会创建实例，则节约内存空间
> ###### 由于懒汉式的实现是线程安全的，这样会降低整个访问的速度，而且每次都要判断。

### 单例 - 双重锁模式
``` java
	// 单利模式 —— 双重锁模式
	public class DoubleLockSingleton {
	
		private volatile static DoubleLockSingleton instance = null;
		private DoubleLockSingleton() {}
		
		public static DoubleLockSingleton getInstance() {
			//先检查实例是否存在，如果不存在才进入下面的同步块
			if (instance == null) {
				//同步块，线程安全的创建实例
				synchronized (DoubleLockSingleton.class) {
					//再次检查实例是否存在，如果不存在才真正的创建实例
					if (instance == null) {
						instance = new DoubleLockSingleton();
					}
				}
			}
			return instance;
		}
	}
```
> ###### 提示：由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。因此一般建议，没有特别的需要，不要使用。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但并不建议大量采用，可以根据情况来选用。
> ##### 所谓“双重检查加锁”机制，指的是：并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法后，先检查实例是否存在，如果不存在才进行下面的同步块，这是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。

### 单例 - Lazy initialization holder class模式
> #### 1、什么是类级内部类？
> ###### 简单点说，类级内部类指的是，有static修饰的成员式内部类。如果没有static修饰的成员式内部类被称为对象级内部类。
> ###### 类级内部类相当于其外部类的static成分，它的对象与外部类对象间不存在依赖关系，因此可直接创建。而对象级内部类的实例，是绑定在外部对象实例中的。
> ###### 类级内部类中，可以定义静态的方法。在静态方法中只能够引用外部类中的静态成员方法或者成员变量。
> ###### 类级内部类相当于其外部类的成员，只有在第一次被使用的时候才被会装载。
> #### 2、多线程缺省同步锁？
> ###### 1.由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时
> ###### 2.访问final字段时
> ###### 3.在创建线程之前创建对象时
> ###### 4.线程可以看见它将要处理的对象时

``` java
	public class LazyInitSingleton {
	
		private LazyInitSingleton() {}
		
		 /**
     	   *    类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例
          *    没有绑定关系，而且只有被调用到时才会装载，从而实现了延迟加载。
        */
		private static class SingletonHolder {
			// 静态初始化器，由JVM来保证线程安全
			private static LazyInitSingleton instance = new LazyInitSingleton();
		}
		
		public static LazyInitSingleton getInstance() {
			return SingletonHolder.instance;
		}
	}
```

### 单例 - 枚举实现单例控制
``` java
		/**
		 * 单例模式 —— 枚举
		 * @author zhangzhihong
		 *
		 */
		public enum EnumSingleton {
			/**
		     * 定义一个枚举的元素，它就代表了Singleton的一个实例。
		     */
			private Resource instance;
			
			EnumSingleton() {
				instance = new Resource();
			}
		    
		    /**
		     * 单例可以有自己的操作
		     */
			public Resource getInstance() {
		        return instance;
		    }
		}
		class Resource{
		}
```
> #### 使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。

### 结构型模式
### 1. **适配器模式（Adapter）**
* 概念：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

> 适配分类：
> ###### 1、类适配器模式
> ###### 2、对象适配器模式

> ### 类适配器：把适配的类的API转换成为目标类的API

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/z0F2DQJq*XJOvToK6pGg1AhB7eisfKn.jWxOjEznEjw!/b/dGgBAAAAAAAA&bo=HAVEAgAAAAARB28!&rf=viewer_4)


#### 适配器角色
* 目标角色（Target）：使用客户端的接口。
* 源角色（Adapee）：需要适配的接口
* 适配器角色（Adaper）：适配器把源接口接口转换成目标接口，具体类

> ### 对象适配器：把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/MxIL*tT8btKMKKbxdhgLIVN6GVKIsaHcz80PrMR3H7Y!/b/dPMAAAAAAAAA&bo=9gR4AgAAAAARB7g!&rf=viewer_4)

#### **类适配器和对象适配器的权衡**
* 类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。
* 1、**对于类适配器**，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理  Adaptee的子类了。
2、**对于类适配器**，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理  Adaptee的子类了。
* 1、**对于类适配器**，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。
2、**对于对象适配器**，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。
* 1、**对于类适配器**，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。
2、**对于对象适配器**，需要额外的引用来间接得到Adaptee。

> #### 适配器模式优点
> ##### 更好的复用性
> 		系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。
> ##### 更好的扩展
>		在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。
> #### 适配器模式缺点
> 过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。

#### **缺省适配模式**
缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省是适配模式在JAVA语言中有着特殊的应用。

>  这些空的方法是一种浪费，有时也是一种混乱。除非看过这些空方法的代码，程序员可能会以为这些方法不是空的。即便他知道其中有一些方法是空的，也不一定知道哪些方法是空的，哪些方法不是空的，除非看过这些方法的源代码或是文档。
>　缺省适配模式可以很好的处理这一情况。可以设计一个抽象的适配器类实现接口，此抽象类要给接口所要求的每一种方法都提供一个空的方法。就像帮助了鲁智深的“上应天星”一样，此抽象类可以使它的具体子类免于被迫实现空的方法。
> ###### ***注:适配器模式的用意是要改变源的接口，以便于目标接口相容。缺省适配的用意稍有不同，它是为了方便建立一个不平庸的适配器类而提供的一种平庸实现。***


### 2. **桥梁模式（Bridge）**
* 概念：又称为柄体(Handle and Body)模式或接口(Interface)模式。桥梁模式的用意是“将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化”。

	##### 桥梁模式的意义：
		* 抽象化：一组对象如果具有相同的特征，那么它们就可以通过一个共同的类来描述。如果一些类具有相同的特征，往往可以通过一个共同的抽象类来描述。
		* 实现化：抽象化给出的具体实现
		* 脱耦：所谓耦合，就是两个实体的行为的某种强关联。而将它们的强关联去掉，就是耦合的解脱，或称脱耦。在这里，脱耦是指将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联。所谓强关联，就是在编译时期已经确定的，无法在运行时期动态改变的关联；所谓弱关联，就是可以动态地确定并且可以在运行时期动态地改变的关联。显然，在Java语言中，继承关系是强关联，而聚合关系是弱关联。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/kb6T6SvLDUYaIE9*KlmSzFueQJUkVoA5kupiRQmuMp4!/b/dF4BAAAAAAAA&bo=IgXoAQAAAAARB*4!&rf=viewer_4)

#### 桥梁模式角色
* 抽象化角色（Abstraction）：抽象化给出的定义，并保存一个对实现化对象的引用。
* 修正抽象化角色（RefinedAbstraction）：扩展抽象化角色，改变和修正父类对抽象化的定义。
* 实现化角色（Implementor）：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。
* 具体实现化角色（ConcreteImplementor）：这个角色给出实现化角色接口的具体实现。

> #### 桥梁模式优点
> ##### 分离抽象和实现部分
> 		桥梁模式分离了抽象部分和实现部分，从而极大地提供了系统的灵活性。让抽象部分和实现部分独立出来，分别定义接口，这有助于对系统进行分层，从而产生更好的结构化的系统。
> ##### 更好的扩展
>		桥梁模式使得抽象部分和实现部分可以分别独立地扩展，而不会相互影响，从而大大提高了系统的可扩展性。


### 3. **组合（合成）模式（Composite）**
* 概念：又叫做“部分——整体”模式。组合模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式可以使客户端将单纯元素与复合元素同等看待。

> 组合模式分类：
> ###### 1、安全式模式
> ###### 2、透明式模式

#### 安全式模式：要求管理聚集的方法只出现在树枝构件类中，而不出现在树叶构件类中。
![](http://m.qpic.cn/psb?/V11AXMr91seOnq/WPd97ckYEfIN.j2sauYP21EWjC.woE2GVgkfvs5RJ1U!/b/dPIAAAAAAAAA&bo=AgRKAgAAAAARB34!&rf=viewer_4)

#### 安全式组合模式角色
* 抽象构件角色（Component）：这是一个抽象角色，它给参加组合的对象定义出公共的接口及其默认行为，可以用来管理所有的子对象。合成对象通常把它所包含的子对象当做类型为Component的对象。在安全式的合成模式里，构件角色并不定义出管理子对象的方法，这一定义由树枝构件对象给出。
* 树叶构件角色（Leaf）：树叶对象是没有下级子对象的对象，定义出参加组合的原始对象的行为。
* 树枝构件角色（Composite）：代表参加组合的有下级子对象的对象。树枝构件类给出所有的管理子对象的方法，如add()、remove()以及getChild()。

> 安全式合成模式的缺点是不够透明，因为树叶类和树枝类将具有不同的接口。

#### 透明式组合模式：透明式的合成模式要求所有的具体构件类，不论树枝构件还是树叶构件，均符合一个固定接口。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/vzdaWHOl4Sl80me4CCrDaCHmW6MwkueXbjEEsE9ShyI!/b/dGgBAAAAAAAA&bo=VAOAAgAAAAARB.U!&rf=viewer_4)

> 客户端无需再区分操作的是树枝对象(Composite)还是树叶对象(Leaf)了；对于客户端而言，操作的都是Component对象。

#### **安全式和透明式选择**
> #### 安全性合成模式是指：从客户端使用合成模式上看是否更安全，如果是安全的，那么就不会有发生误操作的可能，能访问的方法都是被支持的。
> #### 透明性合成模式是指：从客户端使用合成模式上，是否需要区分到底是“树枝对象”还是“树叶对象”。如果是透明的，那就不用区分，对于客户而言，都是Compoent对象，具体的类型对于客户端而言是透明的，是无须关心的。
> ##### 重点：对于合成模式而言，在安全性和透明性上，会更看重透明性，毕竟合成模式的目的是：让客户端不再区分操作的是树枝对象还是树叶对象，而是以一个统一的方式来操作。而且对于安全性的实现，需要区分是树枝对象还是树叶对象。有时候，需要将对象进行类型转换，却发现类型信息丢失了，只好强行转换，这种类型转换必然是不够安全的。***因此在使用合成模式的时候，建议多采用透明性的实现方式***。

### 4. **装饰模式（Decorator）**
* 概念：对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。

> ##### 装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/0W0jB3F4w9*j0kGraxu0hcTLhveoEuSRM0vsMVJxg74!/b/dPIAAAAAAAAA&bo=QASAAgAAAAARB*Y!&rf=viewer_4)

#### 装饰模式角色
* 抽象构件角色（Component）：给出一个抽象接口，以规范准备接收附加责任的对象。
* 具体构件角色（ConcreteComponent）：定义一个将要接收附加责任的类。
* 装饰角色（Decorator）：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。
* 具体装饰角色（ConcreteDecorator）：负责给构件对象“贴上”附加的责任。

> #### **装饰模式的优点**
> ##### 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者除掉一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。
> ##### 通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。
> #### **装饰模式的缺点**
> ##### 由于使用装饰模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是，在另一方面，使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难，特别是这些对象看上去都很相像。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/ISKwnHsDUl10nkuZVIl15q6*Fo7esc44jVDJaOqg95w!/b/dPIAAAAAAAAA&bo=ogW6AQAAAAARByw!&rf=viewer_4)

> #### 注：装饰模式在Java语言中的最著名的应用莫过于Java I/O标准库的设计了。

### 5. **门面模式（Facade）**
* 概念：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。

![](http://a4.qpic.cn/psb?/V11AXMr91seOnq/dpYPEx*G.jbDDNeXnmez.TW61ykncHEFlfrnkqC4E5A!/b/dPMAAAAAAAAA&ek=1&kp=1&pt=0&bo=ZgQCAgAAAAARF0I!&vuin=568244632&tm=1516352400&sce=60-2-2&rf=viewer_4)

#### 门面模式角色
* 门面角色（Facade）：客户端可以调用这个角色的方法。此角色知晓相关的（一个或者多个）子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。
* 子系统角色（SubSystem）：可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合（如上面的子系统就是由ModuleA、ModuleB、ModuleC三个类组合而成）。每个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。

> #### **门面模式的优点**
> ##### 松散耦合
>		门面模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。
> ##### 简单易用
> 		门面模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟门面类交互就可以了。
> ##### 更好的划分访问层次
> 		通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地隐藏了内部的细节。
> #### 注：门面模式在TOMCAT中的使用

### 6. **享元模式（Flyweight）**
* 概念：以共享的方式高效地支持大量的细粒度对象。

#### 享元对象共享关键
1、内蕴状态(Internal State)：一个内蕴状态是存储在享元对象内部的，并且是不会随环境的改变而有所不同。因此，一个享元可以具有内蕴状态并可以共享。
2、外蕴状态(External State)：一个外蕴状态是随环境的改变而改变的、不可以共享的。享元对象的外蕴状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。外蕴状态不可以影响享元对象的内蕴状态，它们是相互独立的。

> 享元模式分类：
> ###### 1、单纯享元模式
> ###### 2、复合享元模式

#### 单纯享元模式
##### 在单纯享元模式中，所有的享元对象都是可以共享的。
![](http://m.qpic.cn/psb?/V11AXMr91seOnq/yCnEVZ4Qo9tH9ND08yZR*YOAf6FfjAH0wCFHgVTiGRg!/b/dD8BAAAAAAAA&bo=SgVAAgAAAAARBz0!&rf=viewer_4)

#### 单纯享元模式角色：
* 抽象享元角色（Flyweight）：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。
* 具体享元角色（ConcreteFlyweight）：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。
* 享元工厂角色（FlyweightFactory）：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。

#### 复合享元模式
##### 将一些单纯享元使用合成模式加以复合，形成复合享元对象。这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/ye*mjlkoz1OWULtXjQSadA5hYVyapOw4CrzgiJHtsU4!/b/dPMAAAAAAAAA&bo=VgdsAgAAAAARFx8!&rf=viewer_4)

#### 复合享元模式角色：
* 抽象享元角色（Flyweight）：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。
* 具体享元角色（ConcreteFlyweight）：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。
* 复合享元角色（ConcreteCompositeFlyweight）：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象。
* 享元工厂角色（FlyweightFactory）：本角 色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有 一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个 合适的享元对象。

> #### **享元模式的优点**
> ###### 享元模式的优点在于它大幅度地降低内存中对象的数量。
> #### **享元模式的缺点**
> ###### 1、享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。
> ##### 2、享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。

> 注：Java的String类型应用享元模式，两个引用都指向了常量池中的同一个字符串常量

### 7. **代理模式（Proxy）**
* 概念： 代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/73r1*qMy2ihku2tmgURDv62QDDhRArzP1FwP2nYGZWY!/b/dD8BAAAAAAAA&bo=rAQMAgAAAAARB5Y!&rf=viewer_4)

### 代理角色
* 抽象对象角色（AbstractObject）：声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。
* 目标对象角色（RealObject）：定义了代理对象所代表的目标对象。
* 代理对象角色（ProxyObject）：代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。


### 行为型模式
### 1. **责任链模式（Chain of Responsibility）**
* 概念：在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/BXHnhvLGcw3DCbKVGbXczIO3cjGd7KmwhRZ64HRruNc!/b/dF4BAAAAAAAA&bo=SgQWAgAAAAARB2o!&rf=viewer_4)

### 责任链模式角色
* 抽象处理角色（Handler）：定义出一个处理请求的接口。如果需要，接口可以定义 出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。上图中Handler类的聚合关系给出了具体子类对下家的引用，抽象方法handleRequest()规范了子类处理请求的操作。
* 具体处理角色（ConcreteHandler）：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。

### 纯的与不纯的责任链模式
######	 一个纯的责任链模式要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又 把责任向下传的情况。
######	 在一个纯的责任链模式里面，一个请求必须被某一个处理者对象所接收；在一个不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。

> 责任链模式在Tomcat中的应用：Tomcat中的Filter就是使用了责任链模式，创建一个Filter除了要在web.xml文件中做相应配置外，还需要实现javax.servlet.Filter接口。


### 2. **命令模式（Command）**
* 概念：命令模式又称为行动(Action)模式或交易(Transaction)模式。命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/YUpbdXMJ5oABa.9msrOHh9ZZh4V**omAkqnFetIThVU!/b/dPMAAAAAAAAA&bo=HgXYAQAAAAARB*I!&rf=viewer_4)

### 命令模式角色
* 客户端角色（Client）：创建一个具体命令(ConcreteCommand)对象并确定其接收者。
* 命令角色（Command）：声明了一个给所有具体命令类的抽象接口。
* 具体命令角色（ConcreteCommand）：定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。
* 请求者角色（Invoker）：负责调用命令对象执行请求，相关的方法叫做行动方法。
* 接受者角色（Receiver）：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。

> 宏命令：所谓宏命令简单点说就是包含多个命令的命令，是一个命令的组合。

### 命令模式优点
> ##### 更松散的耦合
> 	命令模式使得发起命令的对象——客户端，和具体实现命令的对象——接收者对象完全解耦，也就是说发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现。
> ##### 更动态的控制
> 	命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，从而使得系统更灵活。
> ##### 很自然的复合命令
> 	命令模式中的命令对象能够很容易地组合成复合命令，也就是宏命令，从而使系统操作更简单，功能更强大。
> ##### 更好的扩展性
> 	由于发起命令的对象和具体的实现完全解耦，因此扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设置到命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。


### 3. **解释器模式（Interpreter）**
* 概念：给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/kZHCnsJ9O8XvRYNT.bBSxzmz.3r*357eUKfE*MLXfYg!/b/dPIAAAAAAAAA&bo=jwSAAgAAAAARBzk!&rf=viewer_4)

#### 解释器模式角色
* 抽象表达式角色（Expression）：声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要是一个interpret()方法，称做解释操作。
* 终结符表达式角色（Terminal Expression）：实现了抽象表达式角色所要求的接口，主要是一个interpret()方法；文法中的每一个终结符都有一个具体终结表达式与之相对应。比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。
* 非终结符表达式角色（Nonterminal Expression）：文法中的每一条规则都需要一个具体的非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，“+"就是非终结符，解析“+”的解释器就是一个非终结符表达式。
* 环境角色（Context）：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。

> ##### 终结符定义：布尔变量，也就是常量true和false
> ##### 非终结符定义：包含运算符and，or和not等布尔表达式
> #### 文法如下
> ##### **Expression  ::= Constant | Variable | Or | And | Not**
> ##### **And 　　　　::= Expression 'AND' Expression**
> ##### **Or　　　　　::= Expression 'OR' Expression**
> ##### **Not　　　　 ::= 'NOT' Expression**
> ##### **Variable　　::= 任何标识符**
> ##### **Constant    ::= 'true' | 'false'**


### 4. **迭代器模式（Iterator）**
* 概念：又叫游标(Cursor)模式，迭代模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象。

> #### 迭代器模式两种实现方式：
> ##### 1、白箱聚集与外禀迭代		
> ##### 2、黑箱聚集于内禀迭代

#### 白箱聚集与外禀迭代

> #### 名词释义：
> ##### 宽接口：如果一个聚集的接口提供了可以用来修改聚集元素的方法
> ##### 白箱聚集：如果聚集对象为所有对象提供同一个接口，也就是宽接口的话，当然会满足迭代子模式对迭代子对象的要求
> ##### 游标迭代：由于聚集自己实现迭代逻辑，并向外部提供适当的接口，使得迭代子可以从外部控制聚集元素的迭代过程。这样一来迭代子所控制的仅仅是一个游标而已。
> ##### 外禀迭代子：由于迭代子是在聚集结构之外的，因此这样的迭代子又叫做外禀迭代子

#### 白箱聚集与外禀迭代组成的系统图：
![](http://m.qpic.cn/psb?/V11AXMr91seOnq/9b04tU5DR2B9FbX*qPB.SI86r.S.rVJnc.J4c6bqR7c!/b/dGgBAAAAAAAA&bo=XQWAAgAAAAARB.o!&rf=viewer_4)

#### 迭代角色：
* 抽象迭代角色（Iterator）：此抽象角色定义出遍历元素所需的接口。
* 具体迭代角色（ConcreteIterator）：此角色实现了Iterator接口，并保持迭代过程中的游标位置。
* 聚集角色（Aggregate）：此抽象角色给出创建迭代子(Iterator)对象的接口。
* 具体聚集角色（ConcreteAggregate）：实现了创建迭代子(Iterator)对象的接口，返回一个合适的具体迭代子实例。
* 客户端角色（Client）：持有对聚集及其迭代子对象的引用，调用迭代子对象的迭代接口，也有可能通过迭代子操作聚集元素的增加和删除。

> #### 外禀迭代子的意义
> 	客户端当然可以自行进行迭代，不一定非得需要一个迭代子对象。但是，迭代子对象和迭代模式会将迭代过程抽象化，将作为迭代消费者的客户端与迭代负责人的迭代子责任分隔开，使得两者可以独立的演化。在聚集对象的种类发生变化，或者迭代的方法发生改变时，迭代子作为一个中介层可以吸收变化的因素，而避免修改客户端或者聚集本身。

>	此外，如果系统需要同时针对几个不同的聚集对象进行迭代，而这些聚集对象所提供的遍历方法有所不同时，使用迭代子模式和一个外界的迭代子对象是有意义的。具有同一迭代接口的不同迭代子对象处理具有不同遍历接口的聚集对象，使得系统可以使用一个统一的迭代接口进行所有的迭代。

#### 黑箱聚集与内禀迭代
> #### 名词释义：
> ##### 如果一个聚集的接口没有提供修改聚集元素的方法，这样的接口就是所谓的窄接口。
> ##### 在JAVA语言中，实现双重接口的办法就是将迭代子类设计成聚集类的内部成员类。这样迭代子对象将可以像聚集对象的内部成员一样访问聚集对象的内部结构。下面给出一个示意性的实现，说明这种双重接口的结构时怎么样产生的，以及使用了双重接口结构之后迭代子模式的实现方案。这种同时保证聚集对象的封装和迭代子功能的实现的方案叫做黑箱实现方案。
> ##### 由于迭代子是聚集的内部类，迭代子可以自由访问聚集的元素，所以迭代子可以自行实现迭代功能并控制对聚集元素的迭代逻辑。由于迭代子是在聚集的结构之内定义的，因此这样的迭代子又叫做内禀迭代子（Intrinsic Iterator）。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/gzTWE*NegzRzVqSYb8dq8YbgpxLrE7amhcFou7pOwvU!/b/dPIAAAAAAAAA&bo=IAaAAgAAAAARF4Q!&rf=viewer_4)

#### 主动迭代和被动迭代
> ##### 主动迭代子和被动迭代子又称作外部迭代子和内部迭代子。
> ##### 所谓主动（外部）迭代子，指的是由客户端来控制迭代下一个元素的步骤，客户端会明显调用迭代子的next()等迭代方法，在遍历过程中向前进行。
> ##### 所谓被动（内部）迭代子，指的是由迭代子自己来控制迭代下一个元素的步骤。因此，如果想要在迭代的过程中完成工作的话，客户端就需要把操作传递给迭代子，迭代子在迭代的时候会在每个元素上执行这个操作，类似于JAVA的回调机制。

#### 静态迭代和动态迭代
> ##### 静态迭代子由聚集对象创建，并持有聚集对象的一份快照(snapshot)，在产生后这个快照的内容就不再变化。客户端可以继续修改原聚集的内容，但是迭代子对象不会反映出聚集的新变化。
> ##### 静态迭代子的好处是它的安全性和简易性，换言之，静态迭代子易于实现，不容易出现错误。但是由于静态迭代子将原聚集复制了一份，因此它的短处是对时间和内存资源的消耗。
> ##### 动态迭代子则与静态迭代子完全相反，在迭代子被产生之后，迭代子保持着对聚集元素的引用，因此，任何对原聚集内容的修改都会在迭代子对象上反映出来。

##### 动态迭代实例（Fail Fast）
> ###### 如果一个算法开始之后，它的运算环境发生变化，使得算法无法进行必需的调整时，这个算法就应当立即发出故障信号。这就是Fail Fast的含义。
> ###### 如果聚集对象的元素在一个动态迭代子的迭代过程中发生变化时，迭代过程会受到影响而变得不能自恰。这时候，迭代子就应当立即抛出一个异常。这种迭代子就是实现了Fail Fast功能的迭代子。

#### 迭代模式的优点
> ##### 1、迭代子模式简化了聚集的接口。迭代子具备了一个遍历接口，这样聚集的接口就不必具备遍历接口。
> ##### 2、每一个聚集对象都可以有一个或多个迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。因此，一个聚集对象可以同时有几个迭代在进行之中。
> ##### 3、由于遍历算法被封装在迭代子角色里面，因此迭代的算法可以独立于聚集角色变化。

### 5. **中介者模式（Mediator）**
* 概念：用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/eIq7VkevUcz7BgOx78fdq4zhsSQ5k9kpPJEavvybFv4!/b/dPMAAAAAAAAA&bo=lAPaAQAAAAARB3w!&rf=viewer_4)

#### 中介者角色
* 抽象中介者角色（Mediator）：定义好同事类对象到中介者对象的接口，用于各个同事类之间的通信。一般包括一个或几个抽象的事件方法，并由子类去实现。
* 中介者实现角色（ConcreteMediator）：从抽象中介者继承而来，实现抽象中介者中定义的事件方法。从一个同事类接收消息，然后通过消息影响其他同时类。
* 同事角色（Colleague）：如果一个对象会影响其他的对象，同时也会被其他对象影响，那么这两个对象称为同事类。在类图中，同事类只有一个，这其实是现实的省略，在实际应用中，同事类一般由多个组成，他们之间相互影响，相互依赖。同事类越多，关系越复杂。并且，同事类也可以表现为继承了同一个抽象类的一组实现组成。在中介者模式中，同事类之间必须通过中介者才能进行消息传递。

#### 中介模式优点
> ##### 1、适当地使用中介者模式可以避免同事类之间的过度耦合，使得各同事类之间可以相对独立地使用。
> ##### 2、使用中介者模式可以将对象间一对多的关联转变为一对一的关联，使对象间的关系易于理解和维护。
> ##### 3、使用中介者模式可以将对象的行为和协作进行抽象，能够比较灵活的处理对象间的相互作用。

### 6. **备忘录模式（Memento）**
* 概念：又叫做快照模式(Snapshot Pattern)或Token模式，备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捕捉(Capture)住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。备忘录模式常常与命令模式和迭代子模式一同使用。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/Pjy0ql1PheCP25fYudpUopOuYculzrCOEshSy2q2VVw!/b/dPMAAAAAAAAA&bo=9AOGAQAAAAARB0A!&rf=viewer_4)

#### 备忘录模式角色
* 备忘录角色（Memento）：（1）将发起人（Originator）对象的内战状态存储起来。备忘录可以根据发起人对象的判断来决定存储多少发起人（Originator）对象的内部状态。（2）备忘录可以保护其内容不被发起人（Originator）对象之外的任何对象所读取。
* 发起人角色（Originator）：（1）创建一个含有当前的内部状态的备忘录对象。（2）使用备忘录对象存储其内部状态。
* 负责人角色（Caretaker）：（1）负责保存备忘录对象。（2）不检查备忘录对象的内容。

#### “白箱”备忘录模式的实现
> ##### 备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。因此这个实现又叫做“白箱实现”。
> ##### “白箱”实现将发起人角色的状态存储在一个大家都看得到的地方，因此是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。因此白箱实现仍然是有意义的。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/NYPVuGu3Yt5ji8Jqw4xis*e3uvosMwNZ8kCVz1uUau8!/b/dGgBAAAAAAAA&bo=RgYyAgAAAAARB0A!&rf=viewer_4)

#### “黑箱”备忘录模式的实现
> ##### 备忘录角色对发起人（Originator）角色对象提供一个宽接口，而为其他对象提供一个窄接口。这样的实现叫做“黑箱实现”。
> ##### 在JAVA语言中，实现双重接口的办法就是将备忘录角色类设计成发起人角色类的内部成员类。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/x9pRhwOPPYZufD.toXIZYouqZtIxvoVMupIg.k66Qhg!/b/dD8BAAAAAAAA&bo=sASAAgAAAAARFxY!&rf=viewer_4)

#### 多重检查点备忘录模式
> ##### 存储多个检查点

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/rXfbV1Ulb2lEgsQrIbUzcGNuG1oJ9pMwaWewtlYdJUw!/b/dPMAAAAAAAAA&bo=4gWAAgAAAAARF0U!&rf=viewer_4)

#### “自述历史”备忘录模式
> ##### 所谓“自述历史”模式(History-On-Self Pattern)实际上就是备忘录模式的一个变种。在备忘录模式中，发起人(Originator)角色、负责人(Caretaker)角色和备忘录(Memento)角色都是独立的角色。虽然在实现上备忘录类可以成为发起人类的内部成员类，但是备忘录类仍然保持作为一个角色的独立意义。在“自述历史”模式里面，发起人角色自己兼任负责人角色。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/dMkE5U0P5fUmtbzZqNmV7djbxt7hyv.j5fgO1UFuPSg!/b/dPMAAAAAAAAA&bo=WAOAAgAAAAARF*k!&rf=viewer_4)

### 7. **观察者模式（Observer）**
* 概念：又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/4v0xiW5LDeKvT.KJACoAuilvKdOxN7cYxd0QDMUgmm0!/b/dFsBAAAAAAAA&bo=2AT6AQAAAAARBxc!&rf=viewer_4)

#### 观察者模式角色
* 抽象主题角色（Subject）：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。
* 具体主题角色（ConcreteSubject）：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。
* 抽象观察者角色（Observer）：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。
* 具体观察者角色（ConcreteObserver）：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。

> ### 观察者模式方式：推模型和拉模型
> #### 推模型：主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。
> #### 拉模型：主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。
> ##### ***两种模式的比较：***
> ##### 1、推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。
> ##### 2、推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。

### 8. **状态模式（State）**
* 概念：又称状态对象模式（Pattern of Objects for States），状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/p3YJgBJm7*iqJIGTU0Iz4BBRWsTuDUzOfDzKAzpT.JI!/b/dFsBAAAAAAAA&bo=dgTMAQAAAAARB48!&rf=viewer_4)

#### 状态模式角色：
* 环境角色（Context）：也成上下文：定义客户端所感兴趣的接口，并且保留一个具体状态类的实例。这个具体状态类的实例给出此环境对象的现有状态。
* 抽象状态角色（State）：定义一个接口，用以封装环境（Context）对象的一个特定的状态所对应的行为。
* 具体状态角色（ConcreteState）：每一个具体状态类都实现了环境（Context）的一个状态所对应的行为。

> ##### 应用场景：在线投票，通过投票过程中各种状态创建投票管理对象。

### 9. **策略模式（Strategy）**
* 概念：其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/NSA5RKS9fMfzCUfCZjg3QCzLXeWcOWDd1yftJJTCTWc!/b/dPMAAAAAAAAA&bo=WgYCAgAAAAARB2w!&rf=viewer_4)

#### 策略模式角色：
* 环境角色（Context）：持有一个Strategy的引用。
* 抽象策略模式（Strategy）：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。
* 具体策略模式（ConcreteStrategy）：包装了相关的算法或行为。

> #### 策略模式认识
> ##### 策略模式的重心
> 		策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。
> ##### 算法的平等性
> 		策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。
> ##### 运行时策略的唯一性
> 		运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。
> ##### 公有的行为
> 		经常见到的是，所有的具体策略类都有一些公有的行为。

#### **策略模式优点**
> ##### （1）策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。
> ##### 2）使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。

#### **策略模式缺点**
> ##### 1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。
> ##### 2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。

### 10. **模板方法模式（Template Method）**
* 概念：准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/YHL4.oPWn*H4XOckH*6Ar1XCxe4vrArEDf1iec.kuLM!/b/dF4BAAAAAAAA&bo=7gE.AgAAAAARB.M!&rf=viewer_4)

#### 模板方法角色及责任
* **抽象模板角色：**
* 		定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。
* 		定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。
* **具体模板角色：**
* 		实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。
* 	 	每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。

> #### 模板模式重点：子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑。

#### 模板方法模式中的方法分类：模板方法、基本方法
> ### 模板方法:
> ###### 一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。
> ###### 一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。
> 
> ### 基本方法:
 1、抽象方法：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。
 2、具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换。
 3、钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。默认命名规则：钩子方法应当以do开头
> ###### 典型应用：Servlet中的HttpServlet，service()方法中实现了一个或者多个do方法,doPost()/doGet()/...

### 11. **访问者模式（Visitor）**
* 概念：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。

![](http://m.qpic.cn/psb?/V11AXMr91seOnq/mtO4XG7wdPYhCUTMgZ*4K2JraDJmAxp6DOBwWW6Ih1w!/b/dGgBAAAAAAAA&bo=cgOAAgAAAAARB8M!&rf=viewer_4)

#### 访问者模式角色
* 抽象访问者角色（Visitor）：声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口。
* 具体访问者角色（ConcreteVisitor）：实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作。
* 抽象节点角色（Node）：声明一个接受操作，接受一个访问者对象作为一个参数。
* 具体节点角色（ConcreteNode）：实现了抽象节点所规定的接受操作。
* 结构对象角色（ObjectStructure）：有如下的责任，可以遍历结构中的所有元素；如果需要，提供一个高层次的接口让访问者对象可以访问每一个元素；如果需要，可以设计成一个复合对象或者一个聚集，如List或Set。

> ### 访问者模式优点：
> ###### 1、好的扩展性
> 		能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。
> ###### 2、好的复用性
> 		可以通过访问者来定义整个对象结构通用的功能，从而提高复用程度。
> ###### 3、分离无关行为
> 		可以通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。
> ### 访问者模式缺点：
> ###### 1、对象结构变化很困难
> 		不适用于对象结构中的类经常变化的情况，因为对象结构发生了改变，访问者的接口和访问者的实现都要发生相应的改变，代价太高。
> ###### 2、破坏封装
> 		访问者模式通常需要对象结构开放内部数据给访问者和ObjectStructrue，这破坏了对象的封装性。		













